#!/usr/bin/env python3
import os
import re
import sys

# Leanguages igit
igit_cpp = '''# Prerequisites
*.d

# Compiled Object files
*.slo
*.lo
*.o
*.obj

# Precompiled Headers
*.gch
*.pch

# Linker files
*.ilk

# Debugger Files
*.pdb

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la
*.a
*.lib

# Executables
*.exe
*.out
*.app

# debug information files
*.dwo'''

igit_c = '''# Prerequisites
*.d

# Object files
*.o
*.ko
*.obj
*.elf

# Linker output
*.ilk
*.map
*.exp

# Precompiled Headers
*.gch
*.pch

# Libraries
*.lib
*.a
*.la
*.lo

# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib

# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex

# Debug files
*.dSYM/
*.su
*.idb
*.pdb

# Kernel Module Compile Results
*.mod*
*.cmd
.tmp_versions/
modules.order
Module.symvers
Mkfile.old
dkms.conf

# debug information files
*.dwo'''

igit_go = '''# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Code coverage profiles and other test artifacts
*.out
coverage.*
*.coverprofile
profile.cov

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

# Editor/IDE
# .idea/
# .vscode/'''

igit_gradle = '''.gradle
**/build/
!**/src/**/build/

# Ignore Gradle GUI config
gradle-app.setting

# Avoid ignoring Gradle wrapper jar file (.jar files are usually ignored)
!gradle-wrapper.jar

# Avoid ignore Gradle wrappper properties
!gradle-wrapper.properties

# Cache of project
.gradletasknamecache

# Eclipse Gradle plugin generated files
# Eclipse Core
.project
# JDT-specific (Eclipse Java Development Tools)
.classpath'''

igit_java = '''# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
replay_pid*'''

igit_langchain = '''# gitignore template for LangChain products, e.g., LangGraph, LangSmith
# website: https://www.langchain.com/
# website: https://www.langchain.com/langgraph

# LangGraph
.langgraph_api/'''

igit_maven = '''target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
# https://maven.apache.org/wrapper/#usage-without-binary-jar
.mvn/wrapper/maven-wrapper.jar

# Eclipse m2e generated files
# Eclipse Core
.project
# JDT-specific (Eclipse Java Development Tools)
.classpath'''

igit_node = '''# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist
.output

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
.vite/'''

igit_python = '''# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
# .python-version

# pipenv
# Pipfile.lock

# UV
# uv.lock

# poetry
# poetry.lock
# poetry.toml

# pdm
# pdm.lock
# pdm.toml
.pdm-python
.pdm-build/

# pixi
# pixi.lock
.pixi

# PEP 582
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# Redis
*.rdb
*.aof
*.pid

# RabbitMQ
mnesia/
rabbitmq/
rabbitmq-data/

# ActiveMQ
activemq-data/

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre
.pyre/

# pytype
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
# .idea/

# Abstra
.abstra/

# Visual Studio Code
# .vscode/

# Ruff stuff
.ruff_cache/

# PyPI configuration
.pypirc

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

# Streamlit
.streamlit/secrets.toml'''

igit_qt = '''# C++ objects and libs
*.slo
*.lo
*.o
*.a
*.la
*.lai
*.so
*.so.*
*.dll
*.dylib

# Qt-es
object_script.*.Release
object_script.*.Debug
*_plugin_import.cpp
/.qmake.cache
/.qmake.stash
*.pro.user
*.pro.user.*
*.qbs.user
*.qbs.user.*
*.moc
moc_*.cpp
moc_*.h
qrc_*.cpp
ui_*.h
*.qmlc
*.jsc
Makefile*
*build-*
*.qm
*.prl

# Qt unit tests
target_wrapper.*

# QtCreator
*.autosave

# QtCreator Qml
*.qmlproject.user
*.qmlproject.user.*

# QtCreator CMake
CMakeLists.txt.user*

# QtCreator 4.8< compilation database
compile_commands.json

# QtCreator local machine specific files for imported projects
*creator.user*

*_qmlcache.qrc'''

igit_scala = '''*.class
*.log

# virtual machine crash logs
hs_err_pid*'''

igit_swift = '''# Xcode

## User settings
xcuserdata/

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
.build/

# CocoaPods
# Pods/

# Carthage
Carthage/Build/

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output'''

igit_tex = '''## Core latex/pdflatex auxiliary files:
*.aux
*.lof
*.log
*.lot
*.fls
*.out
*.toc
*.fmt
*.fot
*.cb
*.cb2
.*.lb

## Intermediate documents:
*.dvi
*.xdv
*-converted-to.*
# *.ps
# *.eps
# *.pdf

## Generated if empty string is given at "Please type another file name for output:"
.pdf

## Bibliography auxiliary files
*.bbl
*.bbl-SAVE-ERROR
*.bcf
*.bcf-SAVE-ERROR
*.blg
*-blx.aux
*-blx.bib
*.run.xml

## Build tool auxiliary files
*.fdb_latexmk
*.synctex
*.synctex(busy)
*.synctex.gz
*.synctex.gz(busy)
*.pdfsync
*.rubbercache
rubber.cache

## Build tool directories
latex.out/

## Auxiliary/intermediate from other packages
*.alg
*.loa
*.thm
*.cut
*.cpt
*.spl
*.ent
*.lox
*.mf
*.mp
*.t[1-9]
*.tfm
*.end
*.[1-9]
*.acn
*.acr
*.glg
*.glo
*.gls
*.lol
*.idx
*.ilg
*.ind
*.maf
*.mlf
*.mlt
*.mtc[0-9]*
*.pyg
*.mw
*.nlg
*.nlo
*.nls
*.pax
*.pdfpc
*.sagetex.sage
*.sagetex.py
*.sagetex.scmd
*.wrt
*.spell.bad
*.spell.txt
*.upa
*.upb
*.pytxcode
pythontex-files-*/
*.listing
*.loe
*.dpth
*.md5
*.auxlock
*.ptc
*.tdo
*.hst
*.ver
*.lod
*.xcp
*.xmpi
*.xdy
*.xyc
*.xyd
*.ttt
*.fff
TSWLatexianTemp*
*.bak
*.sav
*.bak[0-9]*
.texpadtmp
*.lyx~
*.backup
.*.swp
*~[0-9]*
*.tps
./auto/*
*.el
*-tags.tex
*.sta
*.lpz
*.xwm
#*Notes.bib'''

igit_terraform = '''# Local .terraform directories
.terraform/

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Sensitive data files
*.tfvars
*.tfvars.json

# Ignore override files
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Lock info files
.terraform.tfstate.lock.info

# CLI config files
.terraformrc
terraform.rc'''

# OS igit
igit_linux = '''*~

.fuse_hidden*
.directory
.Trash-*
.nfs*
nohup.out'''

igit_windows = '''# Windows thumbnail cache files
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk'''

igit_macos = '''# General
.DS_Store
__MACOSX/
.AppleDouble
.LSOverride
Icon[
]

# Thumbnails
._*

# Files in root of volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Remote AFP
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk'''

# Editors igit
igit_vsc = '''.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets
!*.code-workspace
.vscode/

# Built VS Code Extensions
*.vsix'''

igit_xcode = '''## User settings
xcuserdata/'''

igit_jetbrains = '''# Covers JetBrains IDEs
# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839

# User-specific stuff
.idea/
.idea/**/workspace.xml
.idea/**/tasks.xml
.idea/**/usage.statistics.xml
.idea/**/dictionaries
.idea/**/shelf

# AWS
.idea/**/aws.xml

# Generated
.idea/**/contentModel.xml

# Sensitive/high-churn
.idea/**/dataSources/
.idea/**/dataSources.ids
.idea/**/dataSources.local.xml
.idea/**/sqlDataSources.xml
.idea/**/dynamic.xml
.idea/**/uiDesigner.xml
.idea/**/dbnavigator.xml

# Gradle
.idea/**/gradle.xml
.idea/**/libraries

# CMake
cmake-build-*/

# Mongo Explorer
.idea/**/mongoSettings.xml

# File-based project format
*.iws

# IntelliJ
out/

# sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Cursive plugin
.idea/replstate.xml

# SonarLint plugin
.idea/sonarlint/
.idea/sonarlint.xml

# Crashlytics plugin
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties

# Editor-based HTTP Client
.idea/httpRequests
http-client.private.env.json

# Android Studio cache file
.idea/caches/build_file_checksums.ser

# Apifox
.idea/.cache/.Apifox_Helper
.idea/ApifoxUploaderProjectSetting.xml
'''

# Dictionaries: option to gitignore section
languages_to_igit_dict = {
    "cpp": igit_cpp,
    "c": igit_c,
    "go": igit_go,
    "gradle": igit_gradle,
    "java": igit_java,
    "langchain": igit_langchain,
    "maven": igit_maven,
    "node": igit_node,
    "python": igit_python,
    "qt": igit_qt,
    "scala": igit_scala,
    "swift": igit_swift,
    "tex": igit_tex,
    "terraform": igit_terraform,
}

system_to_igit_dict = {
    "linux": igit_linux,
    "windows": igit_windows,
    "macos": igit_macos,
}

editor_to_igit_dict = {
    "vsc": igit_vsc,
    "xcode": igit_xcode,
    "jetbrains": igit_jetbrains,
}

def file_init():
    try:
        file = open(".gitignore", "x")
        file.write("# =-=-=-=-=-=-=-=-=-= Languages =-=-=-=-=-=-=-=-=-=\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= END Languages =-=-=-=-=-=-=-=-=-=\n\n\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= System =-=-=-=-=-=-=-=-=-=\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= END System =-=-=-=-=-=-=-=-=-=\n\n\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= Editors =-=-=-=-=-=-=-=-=-=\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= END Editors =-=-=-=-=-=-=-=-=-=\n\n\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= Custom User Section =-=-=-=-=-=-=-=-=-=\n\n")
        file.write("# =-=-=-=-=-=-=-=-=-= END Custom User Section =-=-=-=-=-=-=-=-=-=")
        file.flush()
        file.close()
    except FileExistsError: pass

def check_argv() -> None:
    '''
    Only checking here if argv doesnt not collide with each other and also if the commands exist. Doesnt check the parameters here, they are chedcked in every command handler
    :return:
    '''
    creating_igit_state = False
    modifying_igit_state = False

    adding_igit_state = False
    excluding_igit_state = False

    for arg in sys.argv:
        if arg.startswith("--"):
            arg = arg.strip('-')

            if (arg == 'help' or arg == 'h' or arg == 's' or arg == 'state' or arg == 'list') and len(sys.argv) != 2:
                print(f"\033[91m[ERROR] Please use --help or --state or --list without other options")
                sys.exit(1)

            if arg == 'exclude_lang' or arg == 'exclude_sys' or arg == 'exclude_editor':
                creating_igit_state = True
                excluding_igit_state = True
                if os.path.exists(".gitignore"):
                    print(f"\033[91m[ERROR] Please delete the .gitignore file before creating new one")
                    sys.exit(0)
            elif arg == "lang" or arg == "sys" or arg == "editor":
                creating_igit_state = True
                adding_igit_state = True
                if os.path.exists(".gitignore"):
                    print(f"\033[91m[ERROR] Please delete the .gitignore file before creating new one")
                    sys.exit(0)
            elif arg == "add_lang" or arg == "add_sys" or arg == "add_editor" or arg == "del_lang" or arg == "del_sys" or arg == "del_editor":
                modifying_igit_state = True
            elif arg == "help" or arg == 'state' or arg == 'h' or arg == 's' or arg == 'list': pass
            else:
                print(f"\033[91m[ERROR] Unknown option: {arg}")
                sys.exit(1)

    if creating_igit_state and modifying_igit_state:
        print(f"\033[91m[ERROR] Unknown option: {arg}")
        sys.exit(1)

    if adding_igit_state and excluding_igit_state:
        print(f"\033[91m[ERROR] You cannot exclude from all and then make your own gitignore base. Check manual for help")
        sys.exit(1)

def check_if_section_exist(section_name:str, file_name:str = ".gitignore") -> bool:
    with open(file_name, 'r') as file:
        line = file.readline()
        while line:
            if line.startswith(f"# ======= {section_name} ======="):
                return True
            line = file.readline()
    return False

def check_if_section_supported(section_name:str) -> int:
    '''
    Checks if a specific section is in defined in script
    :param section_name: Name of the section
    :return: The value that correspond to a type of section like languages, system or editors. 0 correspond to false
    '''

    if section_name in languages_to_igit_dict.keys():
        return 1
    elif section_name in system_to_igit_dict.keys():
        return 2
    elif section_name in editor_to_igit_dict.keys():
        return 3
    else:
        return 0

def add_section(section_name:str) -> int:
    if check_if_section_exist(section_name, ".gitignore"):
        print(f"\033[38;5;208m[WARNING] Section {section_name} already exists")
        return -1

    section_content = ""
    section_type = ""

    if section_name in languages_to_igit_dict:
        section_type = "Languages"
        section_content = languages_to_igit_dict[section_name]

    if section_name in editor_to_igit_dict:
        section_type = "Editors"
        section_content = editor_to_igit_dict[section_name]

    if section_name in system_to_igit_dict:
        section_type = "System"
        section_content = system_to_igit_dict[section_name]

    os.rename(".gitignore", ".gitignorebuff")


    with open(".gitignore", "x") as gitignore, open(".gitignorebuff", 'r') as gitignorebuff:
        line = gitignorebuff.readline()

        while line:
            if line.startswith(f"# =-=-=-=-=-=-=-=-=-= END {section_type} =-=-=-=-=-=-=-=-=-="):
                gitignore.write(f"# ======= {section_name} =======\n")
                gitignore.write(section_content + '\n')
                gitignore.write(f"# ======= END {section_name} =======\n\n")
            gitignore.write(line)
            line = gitignorebuff.readline()

    os.remove(".gitignorebuff")
    print(f"\033[96m[INFO] Section {section_name} created")

def remove_section(section_name:str) -> int:
    if not check_if_section_exist(section_name, ".gitignore"):
        print(f"\033[38;5;208m[WARNING] Section {section_name} already does not exist")
        return -1

    os.rename(".gitignore", ".gitignorebuff")

    with open(".gitignore", "x") as gitignore, open(".gitignorebuff", 'r') as gitignorebuff:
        line = gitignorebuff.readline()
        section_flag = False

        while line:
            if line.startswith(f"# ======= {section_name} ======="):
                section_flag = True
            elif line.startswith(f"# ======= END {section_name} ======="):
                section_flag = False
                gitignorebuff.readline()
                line = gitignorebuff.readline()

            if not section_flag:
                gitignore.write(line)

            line = gitignorebuff.readline()

    os.remove(".gitignorebuff")
    print(f"\033[95m[INFO] Section {section_name} deleted")

def print_the_state() -> None:
    print("Currently in .gitignore")
    print("Languages:")
    for section in languages_to_igit_dict.keys():
        print(f"\t-{section}: {1 if check_if_section_exist(section) else 0}")
    print("System:")
    for section in system_to_igit_dict.keys():
        print(f"\t-{section}: {1 if check_if_section_exist(section) else 0}")
    print("Editors:")
    for section in editor_to_igit_dict.keys():
        print(f"\t-{section}: {1 if check_if_section_exist(section) else 0}")

def add_command_handler(arg: str, option_selected: str) -> None:
    cutted_option = re.sub('add_', '', option_selected)

    if cutted_option == 'lang':
        if arg not in languages_to_igit_dict:
            print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such language gitingore section as {arg}")
        else:
            add_section(arg)

    elif cutted_option == 'sys':
        if arg not in system_to_igit_dict:
            print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such system gitingore section as {arg}")
        else:
            add_section(arg)

    elif cutted_option == 'editor':
        if arg not in editor_to_igit_dict:
            print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such editor gitingore section as {arg}")
        else:
            add_section(arg)

    else:
        print(f"\033[38;5;208m[WARNING] Unknown option selected: {cutted_option}")

def remove_command_handler(arg: str, option_selected: str) -> None:
    cutted_option = re.sub('del_', '', option_selected)

    if cutted_option == 'lang':
        if arg not in languages_to_igit_dict:
            print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such language gitignore section as {arg}")
        else:
            remove_section(arg)

    elif cutted_option == 'sys':
        if arg not in system_to_igit_dict:
            print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such system gitignore section as {arg}")
        else:
            remove_section(arg)

    elif cutted_option == 'editor':
        if arg not in editor_to_igit_dict:
            print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such editor gitignore section as {arg}")
        else:
            remove_section(arg)

    else:
        print(f"\033[38;5;208m[WARNING] Unknown option selected: {cutted_option}")

def base_command_handler(arg:str) -> None:
    if check_if_section_supported(arg):
       add_section(arg)
    else:
        print(f"\033[38;5;208m[WARNING] Invalid parameter given. No such gitignore section as {arg}")

def help_command_handler():
    print('''
    There is a short manual of how to use a specific command:
    \t --help, -h: a manual page that you see now
    \t --state, -s: a state of existing .gitignore file
    \t --list: prints all available .gitignore sections
    \t --lang, --sys, --editor: creating .gitignore file from scratch with specified sections
    \t --exclude_lang, --exclude_sys, --exclude_editor: creating a file with all sections except those specified by those options
    \t --add_lang, --add_sys, --add_editor: adding to an existing .gitignore file a specified section
    \t --del_lang, --del_sys, --del_editor: deleting from an existing .gitignore file a specified section 
    
    The sections that are currectly supported are:''')

    print("Languages:")
    for lang in languages_to_igit_dict.keys():
        print(f"\t-{lang}")

    print("Systems:")
    for sys in system_to_igit_dict.keys():
        print(f"\t-{sys}")

    print("Editors:")
    for editor in editor_to_igit_dict.keys():
        print(f"\t-{editor}")

    print("(you have to write them as they are)\n\nThe important thing is, if .gitignore already exist, you cannot execute commands such as: --lang, --sys, --editor, --exclude_lang, --exclude_sys, --exclude_editor, they only works on freshly created filed. If you want to modify the existing file use: --add_lang, --add_sys, --add_editor, --del_lang, --del_sys, --del_editor")

def list_command_handler():
    print("Langs: ", end='')
    for section in languages_to_igit_dict.keys():
        print(section, end=' | ')
    print()

    print("Systems: ", end='')
    for section in system_to_igit_dict.keys():
        print(section, end=' | ')
    print()


    print("Editors: ", end='')
    for section in editor_to_igit_dict.keys():
        print(section, end=' | ')
    print()

if __name__ == "__main__":
    check_argv()
    file_init()

    # if no specific options are given then everything is put inside .gitignore file
    base_state = True

    # Option such as: --exc triggers the state, then in option_selected, the option that was recently choosen is being holds
    option_state = False
    option_selected = ""

    excluded_sections = []

    for arg in sys.argv[1:]:

        # handler for help commnad
        if arg == "--help" or arg == "-h":
            help_command_handler()
            sys.exit(0)

        # handler for state command
        if arg == "--state" or arg == "-s":
            print_the_state()
            sys.exit(0)

        if arg == '--list':
            list_command_handler()
            sys.exit(0)

        # parsing the arguments
        if arg.startswith("--"):
            option_state = True
            option_selected = arg.strip('-')
            continue

        # adding option handler
        if option_state and re.match('add_*', option_selected):
            base_state = False
            add_command_handler(arg, option_selected)
        # remove option handler
        elif option_state and re.match('del_*', option_selected):
            base_state = False
            remove_command_handler(arg, option_selected)
        # excluding from whole base handler
        elif option_state and re.match('exclude_*', option_selected):
            if check_if_section_supported(arg):
                excluded_sections.append(arg)
            else:
                print(f"\033[91m[ERROR] Invalid parameter given. No such gitingore section as {arg}")
        # base creating handler
        elif option_state and (option_selected == 'lang' or option_selected == 'sys' or option_selected == 'editor'):
            base_state = False
            base_command_handler(arg)


    # only fired when --exclude option or no option given
    if base_state:
        for section_name in languages_to_igit_dict.keys():
            if section_name not in excluded_sections:
                add_section(section_name)

        for section_name in system_to_igit_dict.keys():
            if section_name not in excluded_sections:
                add_section(section_name)

        for section_name in editor_to_igit_dict.keys():
            if section_name not in excluded_sections:
                add_section(section_name)